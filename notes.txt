What is typescript ?
Static Typed, Superset of Js to provide efficient debugging.
adds helpful and productive features over js
originally developed to handle large projects but cann handle smaller ones too.
It also refers to the compiler which trans-compiles code written in ts syntax to js which is widely supported accross all browsers

Types of Js features :
1. widely suppported : adopted by all browsers
2. es current : specified in the docs but still not adopted by all browsers
3. es future : to be added in future to js
With ts using all these features is possible along with other features in modern browsers
the ts transpiler converts strong , static typed ts to plain js which any browser can understand

advantages of js:
1.catch errors at compile time instead of run time 
2.better tooling support (refactoring, autocomplete and so on)
3.explicitly express intent

/** all code along changes have been made by me in Ch01/01_01 folder **/

/////Chapter 01

Start:
1. install nodejs and then install typescript globally using npm
2. in the root directory of your project file add the tsconfig.json file
3. In src folder add model.ts then type tsc -w (for watching changes)
4. You will notice a dist folder being with a file model.js w
5. This will consist of all the transpiled js code originally written in ts in model.ts

Primitive Types in Js :
String , Boolean, Number, BigInt, Null, Undefined, Symbol(ES6), 

Complex Types in Js : Objects(complex) - types such as dates and Arrays and even functions fall under this umbrella

We can define types explicitly in ts 
for variable : let name: string = "adeeb"
for functions :  function getInventoryItem(trackingNumber: string): void {}
   the return type can also be Object
   we can also define the structure of the object instead of simply writing object instead of void
    
    function getInventoryItem(trackingNumber: string): {
        displayName: string;
        inventoryType: string;
        trackingNumber: string;
        createDate: Date;
        originalCost: number; 
    } {
        return null;
    }

Type Inference 
: Typescript can infer types of variables from the value assigned to it in some cases
    let inventoryItem = getInventoryItem(trackingNumber);
    here invertoryItem will be assigned the return type of getInventoryItem
    we dont need to define the inventoryItem type explicitly in this case

Gradual typing
: In JS we can change the types of variable dynamically, for eg
  let money = 23; //number 
  money = "A lot"; //redefined to string
  is allowed in js

  To allow this in ts we can define the type of a variable as any
  let originalCost: any = 425;
  originalCost = "A lot of money"
  However, It is not recommended to use this feature in ts unless you really need it

///Chapter 02

Interfaces 
: to describe the structure/shape of an object we can use Interface
    interface InventoryItem { //InventoryItem is the a Custom Type
        displayName: string;
        inventoryType: string;
        trackingNumber: string;
        createDate: Date;
        originalCost: number; 
    }
     //Now the getInventoryItem function can be rewritten as 
    function getInventoryItem(trackingNumber: string): InventoryItem {
        return null;
    }

: this functionality is just to provide code reusability and to help ts
  ts to identify types efficiently so that it can find errors for you easily.
  This will not be reflected in the js code that is rendered.

: if we create and use an object which is not explictly defined 
  as InventoryItem but has the same structure then js will identify 
  it to be of the type InventoryItem implicitly due to its property
  of ducktyping( if an animal behaves and looks like a duck then it is
  a duck although no one has defined it to be a duck).

: We can define attributes and methods in interface to be optional too
  
    interface InventoryItem {
        displayName: string;
        inventoryType: string;
        readonly trackingNumber: string;
        createDate: Date;
        originalCost?: number;  //optional attribute
        addNote?: (note: string) => string; //optional function
    }

    saveInventoryItem({
            displayName: "MacBook Pro 15 Retina",
            inventoryType: "computer",
            trackingNumber: "MBP123456",
            createDate: new Date(),
    }); 

 //duck typing into effect, a new object is implicitly considered to 
  be of type InventoryItem because the its structure matches

: we can define attributes to be read only in interfaces to restrict changes

Enums :

    enum InventoryItemType {
        Computer = "computer",
        Furniture = "furniture"
    }

    interface InventoryItem {
        displayName: string;
        inventoryType: InventoryItemType;
        readonly trackingNumber: string;
        createDate: Date;
        originalCost?: number; //optional attribute
        addNote?: (note: string) => string; //optional method 
    }

    saveInventoryItem({
        displayName: "MacBook Pro 15 Retina",
        inventoryType: InventoryItemType.Computer, //refer to enum items like this
        trackingNumber: "MBP123456",
        createDate: new Date(),
    });

: this will be reflected in the rendered code
  (function (InventoryItemType) {
    InventoryItemType["Computer"] = "computer";
    InventoryItemType["Furniture"] = "furniture";
  })(InventoryItemType || (InventoryItemType = {}));

Literals 
: A more simple approach in this case would be to use Literals
    interface InventoryItem {
        displayName: string;
        inventoryType: "computer" | "furniture"; //using literals instead of enums
        readonly trackingNumber: string;
        createDate: Date;
        originalCost?: number; //optional attribute
        addNote?: (note: string) => string; //optional method 
    }

    saveInventoryItem({
        displayName: "MacBook Pro 15 Retina",
        inventoryType: "computer",
        trackingNumber: "MBP123456",
        createDate: new Date(),
    });

: in case of incorrect value we will get compile time error instead of runtime error
  which would have been the case if we used js

Union types
: In case we want a variable to accept more than 1 types 
 let originalCost: string | number = 425;
 //only these two types would be acceptible
 //any would accept all types

: Other way
 type Cost = string | number; //alias for string and number union
 let originalCost: Cost = 425;

: However be very careful while using such variables to assign 
  value to another variable
  let originalCost : Cost; // no value assigned type can be string or number 
  let newcost : number = originalCost // will give error 

  solution :
  if( typeOf originalCost === "number" ) let newcost : number = originalCost
  else { let newcost = originalCost } //typescript will define newcost to be string


//Chapter 3 - CLasses

